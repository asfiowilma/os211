---
layout: "layout"
title: "My Top 10 List W04"
permalink: /W04/
---
# Top 10 List of Week 04

This week it's all about [M-M-M-M-M-M-M-M-MA-MA..MANRAY](https://www.youtube.com/watch?v=PWbNkqqGrwM)!! No, it's about memories. Actually, no. It's more about addressing, and pointers, and a little about libraries. I start my journey this week by looking up about memory addressing, here goes~ 

1. [Hardware Protection and Type of Hardware Protection](https://www.geeksforgeeks.org/hardware-protection-and-type-of-hardware-protection/)<br>
    The operating system ensures that the hardwares, such as the processor, monitor, RAM, among other things, are not directly accessible by the user. In general, it's categorized into CPU protection, memory protection, and I/O protection. The memory protection part is the one that's related to this week's material. [Its main purpose is to prevent a process from accessing memory that hasn't been allocated to it](https://en.wikipedia.org/wiki/Memory_protection). One of the methods is by paging the virtual memory, which I will look up about later on. 

2. [Logical and Physical Address in Operating System](https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/)<br>
    Logical address is generated by the CPU while a program is running, whereas physical address identifies a physical location of a required data in a memory. The hardware used for mapping logical address to its corresponding physical address is called a Memory Management Unit or MMU (more on this on the next link). The main difference between the two types of addresses is that the logical address does not exist physically in the memory, while physical address does. 

3. [What is Memory Management Unit?](https://whatis.techtarget.com/definition/memory-management-unit-MMU)<br>
    It's a computer hardware that handles all memory and caching operations associated with the processor. It is the manager of memory, as the name suggests. This unit is also responsible for mapping the logical address to its corresponding physical address, as I've discovered and mentioned from the previous link. The MMU's main responsibilities include hardware memory management (regulates the RAM and cache memory), OS memory management, and application memory management (including recycling freed-up memory space when the operation concludes). But how *exactly* does memory management work? ðŸ¤”

4. [How Operating Systems Manages Address Space](https://study.com/academy/lesson/how-operating-systems-manages-address-space.html)<br>
    This article explains how it all comes together. It mentions again how there are two types of memory addresses and how the MMU relates the two. Furthermore, after reading this I learned that the OS uses several memory management techniques, including swapping, paging, and segmentation. Swapping is the movement of memory addresses during processes, paging works by splitting the address space into equally-sized memory chunks, and segmentation is the process of separating processes into segments of varying sizes. More on each of these methods is the topic I looked up next.

5. [What is Memory Swapping?](https://www.enterprisestorageforum.com/hardware/what-is-memory-swapping/)<br>
    Memory swapping enables an operating system to provide more memory to a running application than is available in physical RAM. This is done to get additional memory. It works by making use of virtual memory and storage space, enabling the computer to run faster and crunch data better. The process itself is managed by the OS or by a virtual machine's hypervisor. At first glance this sounds like wizardry to me. How does one suddenly create more memory from nothingness? Magic âœ¨. 

6. [Paging in Operating System](https://www.geeksforgeeks.org/paging-in-operating-system/)<br>
    Paging is a memory management scheme that eliminates the need for contiguous allocation ([more on this on link #7](https://www.guru99.com/os-memory-management.html)) of physical memory. The physcial address space is conceptually divided into fixed-size blocks called frames, whilst the logical address space is splitted into pages. As such, page size always has to equal the frame size. The addressing was explained a bit on the weekly sync class, and the process reminds me slightly to the one we learned from POK last semester. 

7. [Memory Management in OS: Contiguous, Swapping, Fragmentation](https://www.guru99.com/os-memory-management.html)<br>
    This is the process of coordinating computer memory, assigning portions to various runing programs to optimize the performance of the system. Actually, this article also answers my questions about segmentation as well, it has everything in it ðŸ˜². Contiguous management, mentioned on the previous link, works by allowing all types of the computer's memory (except for a small version for the OS) to be available for one application. Segmented memory management, on the other hand, doesn't provide the application with a linear and contiguous address space. Instead, it uses a segment table that containts the physical address of the section in memory, size, etc. The difference between segmentation and paging is the length -- segments may have different length, whereas pages are always fixed in size. 

8. [Little and Big Endian Mystery](https://www.geeksforgeeks.org/little-and-big-endian-mystery/)<br>
    This mystery has been haunting me ever since PSD days. The main difference of the two is that in little endian machines, the last byte representation of the multibyte data is stored first. On big endian machines, it's done the other way around. The easiest way to remember this is **the little ones get reversed**. It just happens that I always mix up the two and forget this rule by the time exam comes. :")) 

9. [Bi-Endianness?](https://www.pcmag.com/encyclopedia/term/bi-endian)<br>
    I first heard about this from reading the lecture slides. It's something I didn't know could be done. Apparently, some machines have the ability to switch between big endian and little endian ordering. Hence why it's called a bi-endian. Mindblowing. It's almost like being ambidextrous but for computers. OwO

10. [Static Libraries vs. Dynamic Libraries](https://medium.com/swlh/linux-basics-static-libraries-vs-dynamic-libraries-a7bcf8157779)<br>
    The topic I explored next was about libraries. As I understand, this has the exact same concept as the libraries I used for python and javascript. It provides a reusable function to make programmers' lives easier. There are two kinds of libraries: static and dynamic ones. Static libraries combine your work with the library into one binary, whereas dynamic ones create combined work at runtime. There are links to more resources inside the article, including [how to create static library and use it in linux](https://youtu.be/JU-vwvSH_0g) and [static and dynamic linking](https://youtu.be/eW5he5uFBNM). 

That is all for this week's journey of GSGS. This time I connected vscode to my osp guest, so the editing is much smoother. It turns out I do prever vscode over vim after all (even if using vim or vi or nano, whichever you think is best, makes me feel cool like a hackerlady ðŸ˜Ž). I hope these links will be useful to anyone who chooses to click on them.

Have a great week, and see you on the next one~